<!DOCTYPE html>
<html>

<head>
  <script src="libs/twgl.js/dist/5.x/twgl-full.js"></script>
</head>

<body>
  <title>Projeto</title>
  <canvas id="c"></canvas>
</body>
<script id="vs" type="notjs">
uniform mat4 u_worldViewProjection;
uniform vec3 u_lightWorldPos;
uniform mat4 u_world;
uniform mat4 u_viewInverse;
uniform mat4 u_worldInverseTranspose;

attribute vec4 position;
attribute vec3 normal;
attribute vec2 texcoord;

varying vec4 v_position;
varying vec2 v_texCoord;
varying vec3 v_normal;
varying vec3 v_surfaceToLight;
varying vec3 v_surfaceToView;

void main() {
  v_texCoord = texcoord;
  v_position = u_worldViewProjection * position;
  v_normal = (u_worldInverseTranspose * vec4(normal, 0)).xyz;
  
  // to complete
  v_surfaceToLight = u_lightWorldPos - (u_world * position).xyz;
  v_surfaceToView = (u_viewInverse[3] - (u_world * position)).xyz;
  
  gl_Position = v_position;
}
  </script>
<script id="fs" type="notjs">
precision mediump float;

varying vec4 v_position;
varying vec2 v_texCoord;
varying vec3 v_normal;
varying vec3 v_surfaceToLight;
varying vec3 v_surfaceToView;

uniform vec4 u_lightColor;
uniform vec4 u_ambient;
uniform sampler2D u_diffuse;
uniform vec4 u_specular;
uniform float u_shininess;
uniform float u_specularFactor;
uniform int u_is_light_source;

vec4 lit(float l ,float h, float m) {
  return vec4(1.0,
              max(l, 0.0),
              (l > 0.0) ? pow(max(0.0, h), m) : 0.0,
              1.0);
//   return vec4(ambient, diffuse, specular, 1.0);
}

void main() {
  vec4 diffuseColor = texture2D(u_diffuse, v_texCoord);
  vec3 a_normal = normalize(v_normal);
  vec3 surfaceToLight = normalize(v_surfaceToLight);
  vec3 surfaceToView = normalize(v_surfaceToView);

  vec3 halfVector = normalize(surfaceToLight + surfaceToView);

  vec4 temp;

  if (u_is_light_source == 0) {
    temp = lit(dot(a_normal, surfaceToLight), dot(a_normal, halfVector), u_shininess);
  }
  else {
    temp = lit(abs(dot(a_normal, surfaceToLight)), dot(a_normal, halfVector), u_shininess);
  }

  vec4 litR = temp;

  

  vec4 outColor = vec4((
    u_lightColor * (diffuseColor * litR.y + diffuseColor * u_ambient +
    u_specular * litR.z * u_specularFactor)).rgb,
    diffuseColor.a);

  gl_FragColor = outColor;
}



  </script>
  
  <script type="module">
    import * as celestial from './libs/celestial.js/celestial-full.js';
    import * as space from './libs/space.js/space-full.js';

    const m4 = twgl.m4;
    const gl = document.querySelector("canvas").getContext("webgl");
    const programInfo = twgl.createProgramInfo(gl, ["vs", "fs"]);

    // texture src: https://in.pinterest.com/pin/white-texture-free-download-free-for-commercial-use-no-registration-required-add-a-subtle-white-te--430867889343458127/
    const default_texture = twgl.createTexture(gl, { src: 'textures/white.jpeg' });

    let timescale = 30 / 365; // 15 seconds per 365 days
    // bodies
    const sun = celestial.create(gl, timescale, "Sun");
    const mercury = celestial.create(gl, timescale, "Mercury");
    const earth = celestial.create(gl, timescale, "Earth");
    const mars = celestial.create(gl, timescale, "Mars");
    const jupiter = celestial.create(gl, timescale, "Jupiter");

    const moon = twgl.primitives.createSphereBufferInfo(gl, 0.1, 20, 20);
    const celestial_bodies = [
        sun,
        mercury,
        earth,
        mars,
        jupiter
    ];
      
    gl.clearColor(0.0, 0.0, 0.0, 1.0); // black background
    const state = {
      eye: [0, 30, 40],
      target: [0, 0, 0],
      up: [0, 1, 0],
    };

    const interactions = {
      isDragging: false,
      lastX: 0,
      lastY: 0
    }

    // Event listeners for keys
    window.addEventListener('keydown', (event) => space.SpatialHandlingUtils.handleKeyDown(event, state, uniforms, earth, sun));
    
    // Event listeners for mouse
    window.addEventListener('mousedown', (event) => space.SpatialHandlingUtils.handleMouseDown(event, interactions));
    window.addEventListener('mousemove', (event) => space.SpatialHandlingUtils.handleMouseMove(event, interactions, state));
    window.addEventListener('mouseup', (event) => space.SpatialHandlingUtils.handleMouseUp(interactions));
    window.addEventListener('wheel', (event) => space.SpatialHandlingUtils.handleWheel(event, state));


    const uniforms = {
      u_lightWorldPos: sun.worldMatrix,
      u_lightColor: [1, 0.8, 0.8, 1],
      u_ambient: [0, 0, 0, 1],
      u_specular: [1, 1, 1, 1],
      u_shininess: 50,
      u_specularFactor: 1,
      u_diffuse: default_texture,
      u_is_light_source: 0,
      u_draw_orbits: 1
    };

    function render(time) {
      // Atualizações de câmera e tempo

      time *= 0.001;

      // Configurações de canvas
      const canvas = gl.canvas;
      twgl.resizeCanvasToDisplaySize(canvas);
      
      // Define explicitamente o tamanho do canvas
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      // Configurações WebGL
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.enable(gl.DEPTH_TEST);
      gl.enable(gl.CULL_FACE);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      // Configurações de projeção e visão
      const fov = 30 * Math.PI / 180;
      const aspect = canvas.width / canvas.height;
      const zNear = 0.5;
      const zFar = 75;
      const projection = m4.perspective(fov, aspect, zNear, zFar);
      const view = m4.inverse(m4.lookAt(state.eye, state.target, state.up));
      const viewProjection = m4.multiply(projection, view);

      celestial_bodies.forEach((body, index) => {
        body.updateWorldMatrix(time);
        uniforms.u_world = body.worldMatrix;
        uniforms.u_worldInverseTranspose = m4.transpose(m4.inverse(body.worldMatrix));
        uniforms.u_worldViewProjection = m4.multiply(viewProjection, body.worldMatrix);
        uniforms.u_diffuse = body.texture || default_texture;
        if (body.name == "Sun") {
          uniforms.u_is_light_source = 1;
        } else {
          uniforms.u_is_light_source = 0;
        }

        gl.useProgram(programInfo.program);
        twgl.setBuffersAndAttributes(gl, programInfo, body.buffer);
        twgl.setUniforms(programInfo, uniforms);
        twgl.drawBufferInfo(gl, body.buffer);

        if (uniforms.u_draw_orbits == 1 && body.name != "Sun") {
          uniforms.u_is_light_source = 1;
          for (const part of body.path) {
            uniforms.u_world = part.worldMatrix;
            uniforms.u_worldInverseTranspose = m4.transpose(m4.inverse(part.worldMatrix));
            uniforms.u_worldViewProjection = m4.multiply(viewProjection, part.worldMatrix);
            uniforms.u_diffuse = default_texture;
            gl.useProgram(programInfo.program);
            twgl.setBuffersAndAttributes(gl, programInfo, part.buffer);
            twgl.setUniforms(programInfo, uniforms);
            twgl.drawBufferInfo(gl, part.buffer); 

          }
     
        }

      })


      // Configurações da Lua (moon)
      const moon_World = m4.multiply(earth.worldMatrix, m4.rotationY(time)); // Rotação da lua
      const moon_OrbitRadius = 1.5;
      const moon_OrbitPosition = [Math.cos(time * 2) * moon_OrbitRadius, Math.cos(time), Math.sin(time * 2) * moon_OrbitRadius];
      const moon_Position = m4.translation(moon_OrbitPosition);
      m4.multiply(moon_Position, moon_World, moon_World);
      uniforms.u_world = moon_World;
      uniforms.u_worldInverseTranspose = m4.transpose(m4.inverse(moon_World));
      uniforms.u_worldViewProjection = m4.multiply(viewProjection, moon_World);
      // texture src: https://svs.gsfc.nasa.gov/cgi-bin/details.cgi?aid=4720
      uniforms.u_diffuse = twgl.createTexture(gl, { src: 'textures/moon.jpeg' });
      twgl.setBuffersAndAttributes(gl, programInfo, moon);
      twgl.setUniforms(programInfo, uniforms);
      twgl.drawBufferInfo(gl, moon);


      // Solicita o próximo frame de animação
      requestAnimationFrame(render);
    }


    requestAnimationFrame(render);
  </script>
  

</html>